## [3. Understanding Unidirectional Data Flow](https://developer.android.com/codelabs/jetpack-compose-state?continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fcompose%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fjetpack-compose-state#2)

This section is an introduction to the concept of unidirectional data flow using the Android view system.

If you're already familiar with unidirectional data flow and how it can be used to structure code feel free to skip to the next section.

## The UI update loop

Before we get to our TODO app, let's explore the concepts of unidirectional data flow using the Android view system.

What causes **state** to update? In the introduction we talked about state as any value that changes over time. This is only part of the story of state in an Android application.

In Android apps, state is updated in response to events. **Events** are inputs generated from outside our application, such as the user tapping on a button calling an `OnClickListener`, an `EditText` calling `afterTextChanged`, or an accelerometer sending a new value.

**Events** notify a part of a program that something has happened.

For example, a user pressing a button will call a click event.

In all Android apps, there's a core UI update loop that goes like this:

![1be37cbec4304401.png](https://developer.android.com/codelabs/jetpack-compose-state/img/1be37cbec4304401.png)

- **Event** – An event is generated by the user or another part of the program
- **Update State** – An event handler changes the state that is used by the UI
- **Display State** – The UI is updated to display the new state

Managing state in Compose is all about understanding how state and events interact with each other.

## **Unstructured state**

Before we get to Compose, let's explore events and state in the Android view system. As a "Hello, World" of state we are going to build a hello world `Activity` that allows the user to input their name.

![451ab3e0e6cbce39.gif](https://developer.android.com/codelabs/jetpack-compose-state/img/451ab3e0e6cbce39.gif)

One way we could write this is to have the event callback directly set the state in the TextView, and the code, using [`ViewBinding`](https://developer.android.com/topic/libraries/view-binding), might look something like this:

The code for this section is already complete in the `examples` package.

You don't need to make any changes to the source code in this section.

### HelloCodelabActivity**.kt**

```
class HelloCodelabActivity : AppCompatActivity() {

   private lateinit var binding: ActivityHelloCodelabBinding
   var name = ""

   override fun onCreate(savedInstanceState: Bundle?) {
       /* ... */
       binding.textInput.doAfterTextChanged {text ->
           name = text.toString()
           updateHello()
       }
   }

   private fun updateHello() {
       binding.helloText.text = "Hello, $name"
   }
}
```

This code shows unstructured state stored in an Activity.

Code like this does work, and for a small example like this it's fine. However, it tends to become hard to manage as the UI grows.

As you add more events and state to an Activity built like this several problems can arise:

1. **Testing** – since the state of the UI is interwoven with the `Views` it can be difficult to test this code.
2. **Partial state updates** – when the screen has many more events, it is easy to forget to update part of the state in response to an event. As a result the user may see an inconsistent or an incorrect UI.
3. **Partial UI updates** – since we're manually updating the UI after each state change, it's very easy to forget this sometimes. As a result the user may see stale data in their UI that randomly updates.
4. **Code complexity** – it's difficult to extract some of the logic when coding in this pattern. As a result, code has a tendency to become difficult to read and understand.

## Using Unidirectional Data Flow

To help fix these problems with unstructured state, we introduced Android Architecture Components which contain `ViewModel` and `LiveData`.

A `ViewModel` lets you extract *state* from your UI and define *events* that the UI can call to update that state. Let's look at the same Activity written using a `ViewModel`.

![67edaf41f5882075.png](https://developer.android.com/codelabs/jetpack-compose-state/img/67edaf41f5882075.png)

### **HelloCodelabActivity.kt**

```
class HelloCodelabViewModel: ViewModel() {

   // LiveData holds state which is observed by the UI
   // (state flows down from ViewModel)
   private val _name = MutableLiveData("")
   val name: LiveData<String> = _name

   // onNameChanged is an event we're defining that the UI can invoke
   // (events flow up from UI)
   fun onNameChanged(newName: String) {
       _name.value = newName
   }
}

class HelloCodeLabActivityWithViewModel : AppCompatActivity() {
   private val helloViewModel by viewModels<HelloCodelabViewModel>()

   override fun onCreate(savedInstanceState: Bundle?) {
       /* ... */

       binding.textInput.doAfterTextChanged {
           helloViewModel.onNameChanged(it.toString()) 
       }

       helloViewModel.name.observe(this) { name ->
           binding.helloText.text = "Hello, $name"
       }
   }
}
```

In this example, we moved the state from the `Activity` to a `ViewModel`. In a ViewModel, state is represented by `LiveData`. A `LiveData` is an **observable** state holder, which means that it provides a way for anyone to observe changes to the state. Then in the UI we use the `observe` method to update the UI whenever the state changes.

An **observable** is any state object that provides a way for anyone to listen for changes to that state.

For example, [`LiveData`](https://developer.android.com/topic/libraries/architecture/livedata), [`StateFlow`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/), [`Flow`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html), and [`Observable`](http://reactivex.io/documentation/observable.html) are all observable.

The `ViewModel` also exposes one event: `onNameChanged`. This event is called by the UI in response to user events, such as what happens here whenever the `EditText`'s text changes.

Going back to the UI update loop we talked about earlier we can see how this `ViewModel` fits together with events and state.

- **Event** – `onNameChanged` is called by the UI when the text input changes
- **Update State** – `onNameChanged` does processing, then sets the state of `_name`
- **Display State** – `name`'s observer(s) are called, which notifies the UI of state changes

By structuring our code this way, we can think of events flowing "up" to the `ViewModel`. Then, in response to events the `ViewModel` will do some processing and possibly update state. When the state is updated it flows "down" to the `Activity`.

![State flows down from viewmodel to activity, while events flow up from activity to viewmodel.](https://developer.android.com/codelabs/jetpack-compose-state/img/1bb3728573d00d8d.png)

This pattern is called **unidirectional data flow**. Unidirectional data flow is a design where state flows down and events flow up. By structuring our code this way we gain a few advantages:

- **Testability** – by decoupling state from the UI that displays it, it's easier to test both the ViewModel and the Activity
- **State encapsulation** – because state can *only* be updated in one place (the `ViewModel`), it's less likely that you'll introduce a partial state update bug as your UI grows
- **UI consistency** – all state updates are immediately reflected in the UI by the use of observable state holders

So, while this approach does add a bit more code – it tends to be easier and more reliable to handle complex state and events using unidirectional data flow.

**Unidirectional data flow** is a design where events flow *up* and state flows *down*.

For example, in a `ViewModel` events are passed *up* with method calls from the UI while state flows *down* using `LiveData`.

It's not just a term to describe `ViewModel` – any design where events flow up and state goes down is unidirectional.

In the next section we'll see how to use unidirectional data flow with Compose.