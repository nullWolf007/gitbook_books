[TOC]

## http和https解析

#### 参考转载

* [HTTP和HTTPS协议，看一篇就够了](https://blog.csdn.net/xiaoming100001/article/details/81109617)
* [HTTPS理论基础及其在Android中的最佳实践](https://blog.csdn.net/iispring/article/details/51615631)
* [看图学HTTPS](https://juejin.cn/post/6844903608421449742#heading-0)

### 一、基础知识

#### 1.1 http

* 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

#### 1.2 https

* HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

* TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。

### 二、http和https的区别

#### 2.1 http特点

* 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作
* 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量
* 基于请求和响应：基本的特性，由客户端发起请求，服务端响应
* 简单快速、灵活
* 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性

#### 2.2 https特点

* 内容加密：采用混合加密技术，中间者无法直接查看明文内容
* 验证身份：通过证书认证客户端访问的是自己的服务器
* 保护数据完整性：防止传输的内容被中间人冒充或者篡改

### 三、https解析

#### 3.1 HTTP是什么样的？

* HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述：



![http-1](https://user-gold-cdn.xitu.io/2018/5/21/1638197d2ee65cb6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



* 客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。

#### 3.2 加个密呢？

* 因为上图中数据是明文传输的，我们能想到最简单的提高安全性的方法就是在传输前对数据进行加密，如下图：



![http-2](https://user-gold-cdn.xitu.io/2018/5/21/1638197d2f188c52?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



* 这种加密方式叫做：**对称加密**。 加密和解密用同一个秘钥的加密方式叫做对称加密。

* 好了，我们对数据进行加密了，问题解决了吗？

#### 3.3 多个客户端怎么办？

* 这是一个客户端，但是在WWW上，是成千上万的客户端，情况会怎样呢？



![http-3](https://user-gold-cdn.xitu.io/2018/5/21/1638197d2ec7d8ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



* 为所有的客户端都应用同一个秘钥A，这种方式很显然是不合理的，破解了一个用户，所有的用户信息都会被盗取。

* 想一想，是不是还有别的办法呢？

* 相信大家都可以想到，如果对每一个客户端都用不同的秘钥进行传输是不是就解决这个问题了：

![http-4](https://user-gold-cdn.xitu.io/2018/5/21/1638197d2eab0301?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 3.4 对称加密秘钥如何传输？

* 我们对每个客户端应用不同的对称加密秘钥，那么这个秘钥客户端或者服务端是如何知道的呢，只能是在一端生成一个秘钥，然后通过HTTP传输给另一端：

![http-5](https://user-gold-cdn.xitu.io/2018/5/21/1638197d2f463922?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 那么这个传输秘钥的过程，又如何保证加密？如果被中间人拦截，秘钥也会被获取。也许你会说，对秘钥再进行加密，那又如何保证对秘钥加密的过程，是加密的呢？

* 好像我们走入了 **while(1)**，出不来了。

#### 3.5 非对称加密

* 在对称加密的路上走不通了，我们换个思路，还有一种加密方式叫非对称加密，比如RSA。 非对称加密会有一对秘钥：**公钥**和**私钥**。 
* **公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开（当然是指和秘钥是一对的公钥）。**

![http-6](https://user-gold-cdn.xitu.io/2018/5/21/1638197d2f09eab3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 私钥只保存在服务器端，公钥可以发送给所有的客户端。

* 在传输公钥的过程中，肯定也会有被中间人获取的风险，但在目前的情况下，至少可以保证客户端通过公钥加密的内容，中间人是无法破解的，因为私钥只保存在服务器端，只有私钥可以破解公钥加密的内容。

* 现在我们还存在一个问题，如果公钥被中间人拿到篡改呢：

**MITM**：Man-in-the-MiddleAttack

![http-7](https://user-gold-cdn.xitu.io/2018/5/21/1638197d56d46dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 客户端拿到的公钥是假的，如何解决这个问题？

#### 3.6 第三方认证

* 公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。

* 在HTTPS中，使用 **证书 + 数字签名** 来解决这个问题。

![http-9](https://user-gold-cdn.xitu.io/2018/5/21/1638197d961729a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 这里假设加密方式是MD5，将网站的信息加密后通过第三方机构的私钥再次进行加密，生成数字签名。

**数字证书 = 网站信息 + 数字签名**

* 假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题。

![http-10](https://user-gold-cdn.xitu.io/2018/5/21/1638197d6f402850?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 浏览器安装后会内置一些权威第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等，验证签名的时候直接就从本地拿到相应第三方机构的公钥，对私钥加密后的数字签名进行解密得到真正的签名，然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。

#### 3.7 为什么要有签名？

* 大家可以想一下，为什么要有数字签名这个东西呢？

* 第三方认证机构是一个开放的平台，我们可以去申请，中间人也可以去申请呀：

![http-11](https://user-gold-cdn.xitu.io/2018/5/21/1638197d6fb66044?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 如果没有签名，只对网站信息进行第三方机构私钥加密的话，会存在下面的问题：

![http-12](https://user-gold-cdn.xitu.io/2018/5/21/1638197d977c8344?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。
* 浏览器刚开始应该只是知道服务器域名，并不知道具体的ip地址，这样替换之后，浏览器分辨不出是不是被替换了。 但是加了数字签名之后，中间人申请的数字签名肯定是根据自己的服务器域名申请的，肯定和实际的服务器域名申请的数字签名是不一致的，毕竟服务器域名是唯一的。

#### 3.8 对称加密

* 在安全的拿到服务器的公钥之后，客户端会随机生成一个对称秘钥，使用服务器公钥加密，传输给服务端，此后，相关的 **Application Data** 就通过这个随机生成的对称秘钥进行加密/解密，服务器也通过该对称秘钥进行解密/加密：

![http-13](https://user-gold-cdn.xitu.io/2018/5/21/1638197d96d391ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 3.9 整体流程图

* HTTPS = HTTP + TLS/SSL

![http-15](https://user-gold-cdn.xitu.io/2018/5/21/1638197d976620af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 3.10 总结

* HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。

### 四、SSL协议

#### 4.1 概述

* 其实SSL就是第三部分的完整具体实现，比上面更加详细一点。

* [SSL](https://zh.wikipedia.org/wiki/傳輸層安全性協定)（Secure Socket Layer）安全套接层，是一种位于应用层与传输层之间，为网络通信提供安全及完整性验证的一种网络协议。

#### 4.2 SSL协议流程图

* 相对于TCP或HTTP协议，SSL协议要复杂很多。由于它也是建立在TCP协议之上的，所以在使用SSL传输数据之前需要先进行三次握手和服务器建立连接，具体的流程如图所示：

![img](https://user-gold-cdn.xitu.io/2018/5/6/1633532f95052afd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 4.3 SSL协议的握手过程

1. 客户端先给服务端发送一个消息，消息内容包括：客户端支持的加密方式，支持的压缩方法，SSL的版本号，客户端生成的随机数，文本内容“Hello”等；
2. 服务端接收到消息后，也回发一个Hello，并携带从客户端支持的加密方式中选择的加密方式，服务端生成的随机数，服务端的SSL版本号等信息；
3. 随后服务器给客户端发送一个Certificate报文，报文中包含服务端的公钥证书；
4. 紧接着服务器给客户端发送Server Hello Done, 表示最初的协商握手过程结束；
5. 客户端接收到服务端发送的握手结束的消息后，以Client Key Exchange作为回应，此报文中包含通信加密过程中使用的一种被称为Pre-master secret的随机密码串，并使用第三步接收到的公钥证书进行了加密；
6. 接着客户端发送Change Cipher Spec报文，该报文告知服务端，此步骤之后的所有数据将使用第五步中生成的master secret进行加密（master secret的生成过程看后面的介绍）；
7. 随后客户端发送Finish报文，此报文中包含连接至今所有报文的整体校验值，用于完整性验证；
8. 服务端接收到客户端发送的Change Cliper Spec报文后，同样以Change Cliper Spec报文作为回应；
9. 接着服务端发送Finish报文给客户端，表示服务端已正确解析客户端发送的整体校验值，至此，SSL握手的过程结束。
10. 随后开始使用HTTP协议传输使用master secret加密过的数据。

#### 五、问题

#### 5.1 证书的公钥从哪里获取的？

* 设备中内置的CA的公钥
* 首先客户端会用设备中内置的CA的公钥尝试解密数字证书，如果所有内置的CA的公钥都无法解密该数字证书，说明该数字证书不是由一个全球知名的CA签发的，这样客户端就无法信任该服务器的数字证书。





