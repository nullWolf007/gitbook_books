[TOC]

## DVM和ART

#### 参考

* [JVM、DVM、ANDROID RUN TIME(art)的区别（简易篇）](https://www.jianshu.com/p/2bdc60e118f5)
* [Android进阶解密](https://book.douban.com/subject/30358046/)

### 一、DVM

#### 1.1 概述

* Dalvik 虚拟机（ Dalvik Virtual Machine ），简称 Dalvik VM 或者 DVM。
* DVM是Geogle专门为Android平台开发的虚拟机，它运行在Android运行时库中。
* 需要注意的是 DVM 并不是 Java 虚拟机

#### 1.2 JVM和DVM的区别

##### 1.2.1 基于的架构不同

* **JVM基于栈**
  * 意味着需要去栈中读写数据，所需的指令会更多，这样会导致速度变慢，对于性能有限的移动设备，显然不是很适合的。
* **DVM是基于寄存器**
  * 它没有基于栈的虚拟机在复制数据时而使用的大量的出入栈指令，同时指令更紧凑、更简洁。但是由于显式的指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数量的减少， 总的代码数不会增加少。

##### 1.2.2 执行的字节码不同

* **JVM：.class->.jar**
  * 在Java SE 程序中， Java 类被编译成一个或多个 .class 文件，并打包成 jar 文件，而后 JVM会通过相应的.class 文件和 jar 文件获取相应的字节码。执行顺序为.java 文件-> .class 文件->.jar 文件
* **DVM：.class->.dex**
  * 而 DVM 会用 dx 工具将所有的 .class 文件转换为一个.dex 文件，然后 DVM 会从该.dex 文件读取指令和数据， 执行顺序为.java 文-> .class 文件->.dex 文件。


  *   .jar 文件里面包含多个.class 文件，每个.class 文件里面包含了该类的常量池、类信息、属性等。当 JVM 加载该.jar 文件的时候，会加载里面所有的.class 文件， JVM 的这种加载方式很慢，对于内存有限的移动设备并不合适。而在.apk文件中只包含了 .dex 文件，这个.dex 文件将所有的.class 里面所包含的信息全部整合在一起了，这样再加载就加快了速度 。.class 文件存在很多的冗余信息， dex工具会去除冗余信息，并把所有 .class 文件整合到.dex 文件中，减少了 I/O 操作，加快了类的查找速度。

##### 1.2.3 DVM允许在有限的内存中运行多个进程

* DVM经过优化，允许在有限的内存中同时运行多个进程。在 Android 中的每一个应用 都运行在一个DVM 实例中，每一个DVM实例都运行在一个独立的进程空间中，独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭

##### 1.2.4 DVM由Zygote创建和初始化

* Zygote ，它是一个DVM进程，同时也用来创建和初始化 DVM 实例。每当系统需要创建一个应用程序时， Zygote 就会 fork 自身，快速地创建和初始化一个DVM 实例，用于应用程序的运行。对于一些只读的系统库，所有的 DVM 实例都会和 Zygote 共享一块内存区域，节省了内存开销。

##### 1.2.5 DVM有共享机制

* DVM 拥有预加载一共享的机制，不同应用之间在运行时可以共享相同的类，拥有更高 的效率。而 JVM机制不存在这种共享机制，不同的程序，打包以后的程序都是彼此独立的， 即便它们在包里使用了同样的类，运行时也都是单独加载和运行的，无法进行共享。

##### 1.2.6 DVM早期没有JIT编译器

* JVM使用了 JIT 编译器 (Just In Time Compiler ，即时编译器），而 DVM 早期没有使用 JIT 编译器。早期的 DVM 每次执行代码，都需要通过解释器将 dex 代码编译成机器码，然后交给系统处理，效率不是很高。为了解决这一问题，从 Android 2.2 版本开始 DVM 使用 JIT 编译器，它会对多次运行的代码（热点代码）进行编译，生成相当精简的本地机器 码（Native Code ），这样在下次执行到相同逻辑的时候，直接使用编译之后的本地机器码， 而不是每次都需要编译。需要注意的是，应用程序每一次重新运行的时候，都要重做这个编译工作，因此每次重新打开应用程序，都需要JIT编译。

### 二、ART

#### 2.1 概述

* ART (Android Runtime虚拟机是 Android 4.4 发布的，用来替换 Dalvik 虚拟机， Android 4.4 默认采用的还是 DVM ，系统会提供一个选项来开启 ART。在 Android 5.0 版本中默认采用了 ART, DVM 从此退出历史舞台。

#### 2.2 优缺点

##### 2.2.1 优点

* 系统性能显著提神
* 应用启动更快，运行更快，体现更流畅，触感反馈更及时
* 续航能力提升
* 支持更低的硬件

##### 2.2.2 缺点

* 字节码预先编译成机器码，机器码需要的存储空间会多一些，可能增加10%-20%
* 使得应用程序的安装时间变长，尤其是一些复杂的应用

#### 2.3 ART和DVM的区别

##### 2.3.1 JIT和AOT

* **DVM：JIT**
  * DVM中的应用每次运行时，字节码都需要通过JIT编译器编译为机器码，这会使得应用程序的运行效率降低。

* **ART：AOT**
  * 在ART中，系统在安装应用程序时会进行一次 AOT (ahead of time compilation ，预编译），将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了，运行效率会大大提升，设备的耗电 也会降低。
* 这就好比我们在线阅读漫画， DVM 是我们阅读到哪就加载到哪， ART 则是直接加载一章的漫画，虽然一开始加载速度有些慢，但是后续的阅读体验会很流畅。
* 采用 AOT 也会有缺点，主要有两个：第一个是 AOT 会使得应用程序的安装时间变长，尤其是一些复杂的应用；第二个是字节码预先编译成机器码，机器码需要的存储空间会多一些。
* 为了解决上面的缺点， Android 7.0 版本中的 ART 加入了即时编译器 JIT ，作为 AOT 的一个补充， 在应用程序安装时并不会将字节码全部编译成机器码，而是在运行中将热点代码编译成机器码，从而缩短应用程序的安装时间井节省了存储空间。

##### 2.3.2 32和64

* DVM是为32位 CPU 设计的，而 ART 支持64位并兼容32位 CPU ，这也是 DVM 被淘汰的主要原因之一

##### 2.3.3 垃圾回收

* ART 对垃圾回收机制进行了改进，比如更频繁地执行并行垃圾收集，将 GC 暂停 由2次减少为1次等。

##### 2.3.4 运行时堆空间

* ART 的运行时堆空间划分和 DVM 不同



