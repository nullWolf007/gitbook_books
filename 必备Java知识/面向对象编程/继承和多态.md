[TOC]

## 继承和多态

#### 参考

* [Java语言程序设计](https://book.douban.com/subject/26590745/)

### 一、前言

* 继承和多态是Java中的基础内容，所以对于基础使用，这里将不进行说明。重点介绍需要注意的部分。

### 二、继承

#### 2.1 关键点

* 和传统的理解不同，子类并不是父类的一个子集。实际上，一个子类通常比它的父类包含更多的信息和方法。
* 父类中的私有数据域在该类之外是不可访问的。因此，不能在子类中直接使用。但是，如果父类中定义了公共的访问器/修改器，那么可以通过这些公共的访问器/修改器来访问或者修改它们。
* 不是所有的“是一种”（is-a）关系都应该用继承来建模，例如：正方形是一种矩形，但是不应该定义一个Square类来继承Rectangle类，因为width和height属性并不适合正方形。应该定义一个继承自GeometricObject类的Square类，并为正方形边定义一个side属性。
* 继承是用来为“是一种”关系建模的。不要仅仅为了重用方法这个原因而盲目的扩展一个类。例如：尽管Person类和Tree类可以共享类似高度和重量这样的通用特性，但是从Person类扩展出Tree类是毫无意义的。一个父类和它的子类之间必须存在“是一种”关系。
* 某些程序设计语言是允许从几个类派生出一个子类的。这种能力称为**多重继承**。但是**在Java中是不允许多重继承的**。一个Java只能继承自一个父类。这种限制称为**单一继承**。如果使用extends关键字来定义一个子类，它只允许有一个父类。然而，多重继承可以通过接口来实现的。

#### 2.2 super

##### 2.2.1 含义

* super是指这个super关键字所在的类的父类。关键字super可以用于两种途径
  * 调用父类的构造方法
  * 调用父类的方法

##### 2.2.2 调用父类的构造方法

* 语法

```java
super();
super(params)
```

* **必须出现在子类构造方法的第一行，这是显式调用父类构造方法的唯一方式。**

##### 2.2.3 构造方法链

* 构造方法可以调用重载的构造方法或父类的构造方法。如果它们都没有显式的调用，编译器就会自动的将super()作为构造方法的第一条语句。
* 所有的类都直接或间接继承自Object

```java
public ClassName(){
    ///
}

等价于
    
public ClassName(){
	super();//编译器自动补上    
    ///
}   
```

* 在任何情况下，构造一个类实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类的对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程持续到沿着这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。
* 实例

```java

class Person {
    public Person() {
        System.out.println("1.Person");
    }
}

class Employee extends Person {
    public Employee() {
        this("2.invole overload Employee");
        System.out.println("3.Employee");
    }

    public Employee(String s) {
        System.out.println(s);
    }
}

public class Faculty extends Employee {
    public static void main(String[] args) {
        new Faculty();
    }

    public Faculty() {
        System.out.println("4.Faculty");
    }
}
```

* 输出结果

```
1.Person
2.invole overload Employee
3.Employee
4.Faculty
```

* **一般情况下，最好能为每个类提供一个午餐的构造方法，以便于对该类进行扩展，同时避免错误**

##### 2.2.4 调用父类的方法

* 语法

```java
super.方法名(参数)
```

#### 2.3 方法重写

* 仅当实例方法是可访问的，它才能被覆盖。因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系。
* 与实例方法一样，静态方法也能被继承。但是静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：父类名.静态方法名 调用隐藏的静态方法

### 三、多态

#### 3.1 含义

* 多态调用中编译都看父类，父类没有则编译失败
* 运行的时候，对于静态方法，运行父类的静态方法；对于非静态方法，运行子类中的重写方法；对于成员变量，静态和非静态都是用父类的
* 多态意味着父类型的变量可以引用子类型的对象

#### 3.2 动态绑定

##### 3.2.1 声明类型和实际类型

```java
Object o = new String();
System.out.println(o.toString());
```

* 一个变量必须被声明为某种类型。变量的这个类型称为它的声明类型。这里，o的声明类型就是Object。
* 变量的实际类型是被变量引用的对象的实际类，这里o的实际类型是String，因为o指向使用new String()创建的对象，o调用toString()方法由o的实际里欸选哪个决定
* 这就是动态绑定。

##### 3.2.2 动态绑定机制

* 假设对象o是类C1,C2,.....Cn的实例，其中C1是C2的子类，C2是C3的子类，以此类推。Cn为最通用的类。C1为最特殊的类。
* 在Java中Cn就是Object类，如果对象o调用一个方法p，那么JVM会依次在C1.....Cn中查找p的实现，知道找到为止。一旦找到这个实现，就会停止查找，然后调用这个首先找到的实现。

### 四、对象转换

#### 4.1 含义

* 对象的引用可以类型转换为对另一种对象的引用，这称为对象转换。

#### 4.2 向上转换

* 总是可以将一个子类的实例转换成一个父类的变量，称为向上转换，因为子类的实例永远是它的父类的实例。

#### 4.3 向下转换

* 当一个父类的实际转换为它的子类变量（称为向下转换）时，必须使用转换记号（子类名）进行显式转换，向编译器表明你的意图。为使转换成功，必须确保要转换的对象是子类的一个实例，如果父类对象不是子类的一个实例，就会出现运行异常ClassCastException。
* 避免ClassCastException，可以使用instanceof先进行判断，再进行转换。

#### 4.4 基本类型和引用类型

* 转换基本类型值返回一个新的值
* 转换一个对象引用不会创建一个新的对象

### 五、注意点

* 子类可以重写它的父类的protected方法，并把它的可见性修改为public。但是子类不能削弱父类中定义的方法的可访问性。例如：如果一个方法再父类中定义为public，在子类中也必须定义为public。
* 可以使用final修饰符表明一个类是最终类，是不能被继承的；也可以表明一个方法是最终的，是不能被重写的。
