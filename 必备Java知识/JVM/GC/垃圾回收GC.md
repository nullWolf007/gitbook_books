[TOC]
# 关于GC的那些事儿

### 参考链接

* [搞定JVM垃圾回收就是这么简单](https://juejin.im/post/5b85ea54e51d4538dd08f601)
* [JVM垃圾回收机制](https://www.jianshu.com/p/23f8249886c6)

## 一、前言

### 1.1 什么是GC？

* GC(Garbage Collection)也就是垃圾回收

### 1.2 关于Garbage Collector
* Garbage Collector也就是垃圾回收站。在C++语言中，显式的用代码申请内存空间new和释放内存free，这样做的弊端是使用者容易忘记释放内存，造成内存问题，为此java引入了自动管理内存机制，这能解决绝大多数的问题，但有些情况不能解决就会造成内存泄漏。

* Garbage Collector的三大职责：
  * 分配内存
  * 确保任何被引用的对象保留在内存中
  * 回收不能通过引用关系找到的对象的内存

### 1.3 Garbage Collection和Garbage Collector的关系

* Garbage Collector上有一个进程完成上述的职责，这个进程就是Garbage Collection，也就是通常说的GC(垃圾回收)

## 二、Java内存区域

* 详情见[Java内存区域](Java内存区域.html)

## 三、JVM内存区域

### 3.1  JDK1.8之前堆内存

* JVM使用分带式的内存管理方式，将Heap分成三代----新生代，老年代，永久代
  ![jvm内存区域.png](..\..\..\images\必备Java知识\JVM\GC\jvm内存区域.png)

* Young Generation--新生代

  ```text
  所有new的对象(除去大对象)
  该区域的内存管理使用Minor Garbage Collection(小GC)
  该部分进一步分成Eden space，Survivor 0，Survivor 1     
  ```

* Old Generation--老年区

  ```text
  新生代中经过小GC幸存下来的对象
  该区域的内存管理使用Major Garbage Collection(大GC)
  ```

* Permanent Generation--永久代

  ```text
  包括应用的类/方法信息，以及JRE库的类和方法信息
  ```

* 小GC和大GC
  
  * 小GC执行的非常频繁，速度非常快；大GC比小G慢十倍以上；大小GC都发出Stop The World，这样会终止程序的运行，直到GC完成，所以频繁的GC会导致用户感觉卡顿

###  3.2 JDK1.8堆内存

*  在JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。

### 3.3 堆内存分配策略

<img src="..\..\..\images\必备Java知识\JVM\GC\堆内存分配策略.png" alt="堆内存分配策略.png" style="zoom: 33%;" />

#### 3.3.1 对象优先在eden区分配

* 目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

* 大多数情况下(除去大对象)，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC（小GC/新生代GC）。

#### 3.3.2  大对象直接进入老年区

* 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

* **目的**：为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

#### 3.3.3 长期存活的对象将进入老年代

* 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象放在新生代，哪些对象放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。
* 如果对象在`Eden`出生并经过第一次`Minor GC`后仍然能够存活，并且能被`Survivor`容纳的话，将被移动到`Survivor`空间中，并将对象年龄设为1。对象在`Survivor`中每熬过一次 `Minor GC`，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

#### 3.3.4 动态年龄对象判定

* 为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果`Survivor`空间中相同年龄所有对象大小的总和大于`Survivor `间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。

#### 3.3.5 Survivor存在的意义

* 如果没有Survivor区，Eden区每进行一次`Minor GC`，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次`Minor GC`没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。所以，**Survivor的存在意义就是减少被送到老年代的对象，进而减少`Major GC`的发生**。

## 四、 GC流程

* 当使用new创建新的对象时，这个对象就会被分配到Eden space区域

![GC创建新的对象.jpg](..\..\..\images\必备Java知识\JVM\GC\GC创建新的对象.jpg)

* 当Eden space满了的时候，小GC程序会被触发

![GC区域满小GC触发.png](..\..\..\images\必备Java知识\JVM\GC\GC区域满小GC触发.png)

* 此时引用可达对象将会被移到S0区域，然后清空Eden区域，此时引用不可达对象将会被删除，内存回收

![引用可达对象转移.png](..\..\..\images\必备Java知识\JVM\GC\引用可达对象转移.png)

* Eden再次满了，引用可达对象将会移到S1，清空Eden区域和S0区域，引用不可达对象将会被删除，内存回收；此时所有可达对象都在S1，并且有着不一样的年龄，经历过几次小GC，就有多大的年龄

![Eden再次满.png](..\..\..\images\必备Java知识\JVM\GC\Eden再次满.png)

* 当Eden第三次满了，S0和S1的角色互换了

![Eden第三次满.png](..\..\..\images\必备Java知识\JVM\GC\Eden第三次满.png)

* 一直循环

* 当Survivor的区域年龄达到了老年线的时候，此对象就会到达老年区

![当Survivor区的对象年龄达到老年线时.png](..\..\..\images\必备Java知识\JVM\GC\当Survivor区的对象年龄达到老年线时.png)

* 如此步骤，大体流程是

![总体流程.png](..\..\..\images\必备Java知识\JVM\GC\总体流程.png)

## 五、垃圾判定算法

<img src="..\..\..\images\必备Java知识\JVM\GC\垃圾判定算法.png" alt="垃圾判定算法.png" style="zoom:33%;" />

### 5.1 引用计数法

#### 5.1.1 含义

* 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；用对象计数器是否为0来判断对象是否可被回收。

#### 5.1.2 缺点

* 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它**很难解决对象之间相互循环引用的问题**。

* 例子：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。

  ```java
  public class ReferenceCountingGc {
      Object instance = null;
  	public static void main(String[] args) {
  		ReferenceCountingGc objA = new ReferenceCountingGc();
  		ReferenceCountingGc objB = new ReferenceCountingGc();
  		objA.instance = objB;
  		objB.instance = objA;
  		objA = null;
  		objB = null;
  
  	}
  }
  ```

### 5.2 可达性分析法

#### 5.2.1 GC Roots

* 垃圾回收器不会回收GC Roots以及那些被它们间接引用的对象

* GC Roots包含哪些对象呢？
  * Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。例如java运行环境中rt.jar中类， 比如java.util.* package中的类。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots。
  * Thread - 活着的线程
  * Stack Local - Java方法的local变量或参数
  * JNI Local - JNI方法的local变量或参数
  * JNI Global - 全局JNI引用
  * Monitor Used - 用于同步的监控对象
  * Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此就只有留给分析分员去确定哪些是属于"JVM持有"的了。

#### 5.2.2 含义

* 这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![活对象-垃圾.png](..\..\..\images\必备Java知识\JVM\GC\活对象-垃圾.png)

### 5.3 常见问题

#### 5.3.1 不可达的对象并非“非死不可”

* 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。
* 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

#### 5.3.2 如何判断一个常量是废弃常量

* 假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

#### 5.3.3 如何判断一个类是无用的类

* 类需要同时满足下面3个条件才能算是 **“无用的类”** 
  * 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
  * 加载该类的 ClassLoader 已经被回收。
  * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
* 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

## 六、垃圾回收算法

<img src="..\..\..\images\必备Java知识\JVM\GC\垃圾回收算法.png" alt="垃圾回收算法.png" style="zoom:33%;" />

### 6.1 标记-清除算法

![标记清除算法.jpg](..\..\..\images\必备Java知识\JVM\GC\标记清除算法.jpg)

#### 6.1.1 含义

* 算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

#### 6.1.2 问题

* **内存碎片化**：标记清除后会出现大量不连续的碎片。

### 6.2 复制算法

![复制算法.jpg](..\..\..\images\必备Java知识\JVM\GC\复制算法.jpg)

#### 6.2.1 含义

* 复制算法（Copying）是在标记清除算法基础上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。

#### 6.2.2 问题

* **浪费内存**：因为把内存划分成两块大小相等的内存，每次只能使用其中一块。这种代价过大。

### 6.3 标记-整理算法

![标记整理算法.jpg](..\..\..\images\必备Java知识\JVM\GC\标记整理算法.jpg)

#### 6.3.1 含义

* 标记-整理算法标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。

#### 6.3.2 问题

* **效率慢**：标记整理算法解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。标记整理算法对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。

### 6.4 分代收集算法

#### 6.4.1 含义

* 分代收集算法分代收集算法严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳，根据对象存活周期的不同将内存划分为几块。

#### 6.4.2 应用

* 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。

* 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记-清除算法**或者**标记-整理算法**来进行回收。

## 七、垃圾回收器

<img src="..\..\..\images\必备Java知识\JVM\GC\垃圾回收器.png" alt="垃圾回收器" style="zoom:33%;" />

* **如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**
* 因为现在还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**

### 7.1 Serial收集器

![Serial收集器.png](..\..\..\images\必备Java知识\JVM\GC\Serial收集器.png)

#### 7.1.1 含义

* Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

#### 7.1.2 思想

* **新生代采用复制算法，老年代采用标记-整理算法。**

#### 7.1.3 优化

* 虚拟机的设计者们当然知道`Stop The World`带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短。

#### 7.1.4 优势

* **简单而高效（与其他收集器的单线程相比）**，Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。

### 7.2 ParNew收集器

![ParNew收集器.png](..\..\..\images\必备Java知识\JVM\GC\ParNew收集器.png)

#### 7.2.1 含义

* **ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。**

#### 7.2.2 思想

* **新生代采用复制算法，老年代采用标记-整理算法。**

### 7.3 Parallel Scavenge收集器

![parallelScavenge收集器](..\..\..\images\必备Java知识\JVM\GC\parallelScavenge收集器.png)

#### 7.3.1 含义

* Parallel Scavenge 收集器类似于ParNew 收集器。 **那么它有什么特别之处呢？**

  ```
  -XX:+UseParallelGC 
      使用Parallel收集器+ 老年代串行
  
  -XX:+UseParallelOldGC
      使用Parallel收集器+ 老年代并行
  ```

* **Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。**

#### 7.3.2 思想

* **新生代采用复制算法，老年代采用标记-整理算法。**

#### 7.3.3 优势

*  Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。

### 7.4 CMS收集器

#### 7.4.1 含义

* **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。**
* **CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

#### 7.4.2 思想

* **标记-清除算法**

#### 7.4.3 过程

![CMS收集器](..\..\..\images\必备Java知识\JVM\GC\CMS收集器.png)

* **初始标记：** 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 。
* **并发标记：** 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
* **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
* **并发清除：** 开启用户线程，同时GC线程开始对为标记的区域做清扫。

#### 7.4.4 优势

* **并发收集**
* **低停顿**

#### 7.4.5 问题

* **对CPU资源敏感；**
* **无法处理浮动垃圾；**
* **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

### 7.5 G1收集器

#### 7.5.1 含义

* **G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。**
* **G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

#### 7.5.2 特点

- **并行与并发**：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
- **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
- **空间整合**：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
- **可预测的停顿**：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

#### 7.5.3 步骤

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

