[TOC]

## 线程同步之volatile

#### 转载参考

* [让你彻底理解volatile](https://www.jianshu.com/p/157279e6efdb)

* [Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

### 一、基础知识

#### 1.1 前言

* 在上一篇文章中我们深入理解了java关键字[线程同步之Synchronized](必备Java知识/并发编程/并发关键字/线程同步之Synchronized.md)，我们知道在java中还有一大神器就是关键volatile，可以说是和synchronized各领风骚，其中奥妙，我们来共同探讨下。

* 通过上一篇的文章我们了解到synchronized是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而volatile就可以说是java虚拟机提供的最轻量级的同步机制。但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用synchronized。[Java内存模型以及happens-before](必备Java知识/并发编程/并发原理/Java内存模型以及happens-before)告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。

* 现在我们有了一个大概的印象就是：**被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。**

#### 1.2 作用

* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
* 禁止进行指令重排序。
* volatile不会提供任何原子操作，它也不能用来修饰final类型的变量

#### 1.3 简单修改volatile变量步骤

* 读取volatile变量到local
* 修改变量值
* local值写回
* 插入内存屏障，即lock指令，让其他线程可见

##### 1.3.1 可能出现的问题

* volatile 变量写入并不保证线程安全，也不具备原子性。原因很简单，在执行内存屏障之前，不同 线程依旧可以对同一个缓存行持有，一个 线程对同一个缓存行的修改不能让另一个 线程 及时感知，因此出现并发冲突。

### 二、基本使用

#### 2.1 状态标记

```java
//线程1
boolean stop = false;
while(!stop){
  doSomething();
}

//线程2
stop = true;
```

* 这段代码为何有可能导致无法中断线程？
  * 每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。
  * 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。
* 所以这里修改把stop变量设置为volatile，这样就会保证线程1会从主存中去读取，从而拿到正确的值。
  * 使用volatile关键字会强制将修改的值立即写入主存；
  * 使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
  * 由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
* 修改后代码

```java
//线程1
volatile boolean stop = false;
```

#### 2.2 volatile不能保证原子性

##### 2.2.1 实例

* 实例详情见[多线程同步解析](必备Java知识/并发编程/多线程同步解析.md)
* 修改Bank代码如下

```java
public class Bank {
    private volatile int count = 0;//账户余额
    //存钱
    public void addMoney(int money) {
        count += money;
        System.out.println("存进：" + money);
    }
    ......
}
```

* 输出结果还是非常大会小于20000的。导致输出结果和预期不符。

##### 2.2.2 解释说明

* 如某个时刻变量count的值为200，
* 线程1对变量进行增加100的操作，线程1先读取了变量count的原始值，然后此时恰好线程1被阻塞了；
* 然后线程2对变量进行增加100的操作，线程2也去读取变量count的原始值，由于线程1只是对变量count进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量count的缓存行无效，所以线程2会直接去主存读取count的值，发现count的值时200，然后进行加100操作，并把300写入工作内存，最后写入主存。
* 然后线程1接着进行增加100的操作，由于已经读取了count的值，注意此时在线程1的工作内存中count的值仍然为200，所以线程1对count进行加100操作后count的值为300，然后将300写入工作内存，最后写入主存。
* 那么两个线程分别进行了一次增加100的操作后，count只增加了100。
* 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对count值进行修改。然后虽然volatile能保证线程2对变量count的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。
* 根源就在这里，增加100操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。

##### 2.2.3 小结

* 主要的我目前认为的原因是，只会刷新内存中的值，以及通知其他CPU失效，其他CPU会从内存中读取数据到CPU缓存中。但是方法里的数据是读取到寄存器中，不会刷新寄存器中的值。所以两个线程同时读取到同样的值到CPU缓存中，然后读取到寄存器中，然后对其进行操作，有一个线程先写入内存，另外一个线程的CPU缓存会刷新，但是寄存器不会刷新，就按旧值进行操作，再写入内存中，就会出现问题。

#### 2.3 volatile一定程度有序性

* volatile关键字禁止指令重排序有两层意思：

  * 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
  * 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

* 举例

  ```java
  //x、y为非volatile变量
  //flag为volatile变量
   
  x = 2;        //语句1
  y = 0;        //语句2
  flag = true;  //语句3
  x = 4;         //语句4
  y = -1;       //语句5
  ```

* 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。

* 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。

* 那么我们回到前面举的一个例子：

  ```java
  //线程1:
  context = loadContext();   //语句1
  inited = true;             //语句2

  //线程2:
  while(!inited ){
  	sleep()
  }
  doSomethingwithconfig(context);
  ```

* 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。

* 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。

### 三、 volatile实现原理

#### 3.1 Lock前缀指令

* volatile是怎样实现了？比如一个很简单的Java代码：

```java
instance = new Instancce()  //instance是volatile变量
```

* 在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出**Lock前缀的指令**（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。

#### 3.2 Lock前缀指令作用

* lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
  * 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
  * 它会强制将对缓存的修改操作立即写入主存；
  * 如果是写操作，它会导致其他CPU中对应的缓存行无效。
* 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性**协议，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

#### 3.3 小结

* Lock前缀的指令会引起处理器缓存写回内存；

* 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；

* 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。

### 四、应用场景

#### 4.1 条件

* 由于violtile无法保证其原子性，所以一般使用的时候由如下的条件
  * 对变量的写操作不依赖于当前值
  * 该变量没有包含在具有其他变量的不变式中

#### 4.2 状态标记

```java
volatile boolean flag = false;

while(!flag){
    doSomething();
}

public void setFlag() {
    flag = true;
}
```

```java
volatile boolean inited = false;
//线程1:
context = loadContext();  
inited = true;            

//线程2:
while(!inited ){
sleep()
}
doSomethingwithconfig(context);
```
