[TOC]
- <!-- TOC -->
  - [ 线性排序](#线性排序)
  - [ 参考](#参考)
    - [ 一、桶排序](#一、桶排序)
      - [ 1.1 原理](#11-原理)
      - [ 1.2 举例](#12-举例)
      - [ 1.3 复杂度](#13-复杂度)
        - [ 1.3.1 时间复杂度](#131-时间复杂度)
      - [ 1.4 限制条件](#14-限制条件)
      - [ 1.5 适用场景](#15-适用场景)
      - [ 1.6 代码实例](#16-代码实例)
    - [ 二、计数排序](#二、计数排序)
      - [ 2.1 原理](#21-原理)
      - [ 2.2 步骤和实例](#22-步骤和实例)
      - [ 2.3 复杂度](#23-复杂度)
        - [ 2.3.1 时间复杂度](#231-时间复杂度)
        - [ 2.3.2 空间复杂度](#232-空间复杂度)
      - [ 2.4  限制条件](#24--限制条件)
      - [ 2.5 适用场景](#25-适用场景)
      - [ 2.6 实例代码](#26-实例代码)
    - [ 三、基数排序](#三、基数排序)
      - [ 3.1 原理](#31-原理)
      - [ 3.2 实例](#32-实例)
      - [ 3.3 复杂度](#33-复杂度)
        - [ 3.3.1 时间复杂度](#331-时间复杂度)
      - [ 3.4 限制条件](#34-限制条件)
      - [ 3.5 稳定排序和不稳定排序](#35-稳定排序和不稳定排序)
        - [ 3.5.1 稳定排序](#351-稳定排序)
        - [ 3.5.2 不稳定排序](#352-不稳定排序)
      - [ 3.6 实例代码](#36-实例代码)
  <!-- /TOC -->
## 线性排序

#### 参考

* [数据结构与算法之美](https://time.geekbang.org/column/article/42038)

### 一、桶排序

#### 1.1 原理

* 核心思想就是把数据分散到m个桶中，然后对m个桶中数据进行排序，然后再把每个桶中的数据依次取出，组成的数据就是有序的了

#### 1.2 举例

![](..\..\images\数据结构及算法\排序算法\桶排序实例.jpg)

* 我们把数据分成了5个桶，然后把数据放入对应的桶中，然后对桶中的数据进行排序，最后再依次取出。

#### 1.3 复杂度

##### 1.3.1 时间复杂度

* O(n)
* 如果要排序的数据有 `n `个，均匀地划分到 `m` 个桶内，每个桶里就有 `k=n/m` 个元素。每个桶内部使用快速排序，时间复杂度为 `O(k * logk)`。`m` 个桶排序的时间复杂度就是 `O(m * k * logk)`，因为` k=n/m`，所以整个桶排序的时间复杂度就是 `O(n*log(n/m))`。当桶的个数 `m` 接近数据个数 `n `时，`log(n/m)` 就是一个非常小的常量，这个时候桶排序的时间复杂度接近` O(n)`。

#### 1.4 限制条件

* 需要排序的数据很容易能够划分成m个桶
* 桶和桶之间存在天然的顺序关系，这样桶与桶之间的数据不用再排序了
* 数据在各个桶的分布应该是比较均匀的

#### 1.5 适用场景

* 桶排序比较适合用在外部排序
* 外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中

#### 1.6 代码实例

* 主要步骤
  * 计算最大值最小值
  * 计算桶数
  * 初始化桶
  * 插入数据到桶中
  * 对桶内数据进行排序
  * 把桶中数据依次取出放入数组中

* 桶内排序采用的快速排序，[常见排序算法](常见排序算法.md)

```java
public class BucketSort {

    public static void main(String[] args) {
        int[] arr = new int[]{15, 25, 30, 6, 12, 13, 17, 18, 24, 27, 28, 32, 25, 37, 36, 45};
        int divsion = 10;
        sort(arr, divsion);
    }

    /**
     * 桶排序
     * arr原始数组
     * divsion 表示间隔空间
     */
    public static void sort(int[] arr, int divsion) {
        //计算最大值最小值
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
            min = Math.min(min, arr[i]);
        }

        //计算桶数
        int m = (max - min) / divsion + 1;

        //初始化桶
        List<Integer>[] buckets = new List[m];
        for (int i = 0; i < buckets.length; i++) {
            buckets[i] = new ArrayList<>();
        }

        //插入数据到对应的桶中
        for (int i = 0; i < arr.length; i++) {
            buckets[(arr[i] - min) / divsion].add(arr[i]);
        }

        //对桶内数据进行排序
        //这里使用快速排序 任意排序方法都可以
        //然后把数据 放到arr数组中
        int index = 0;
        for (int i = 0; i < buckets.length; i++) {
            int[] bucketArr = buckets[i].stream().mapToInt(Integer::valueOf).toArray();
            quickSort(bucketArr, 0, bucketArr.length - 1);
            System.arraycopy(bucketArr, 0, arr, index, bucketArr.length);
            index += bucketArr.length;
        }
        return;
    }
}
```

### 二、计数排序

#### 2.1 原理

* 计数排序可以理解为桶排序的特例，计数排序中每个桶只放入相同的数据，因此减少了桶内排序的时间

#### 2.2 步骤和实例

> 数组A[]: {2，5，3，0，2，3，0，3}

* 对于源数组A[]找到最大值max

> 最大值max=5

* 开辟辅助空间[0-max)大小的数组C[max+1]

> 开辟空间 int[] C = new int[6]

* 遍历A数组，数字对应数组索引，数组值对应每个数字出现的次数

![计数排序实例1](..\..\images\数据结构及算法\排序算法\计数排序实例1.jpg)

> C[0]=2就表示0数字出现的次数为2次

* 遍历C数组，然后计算前面的数据和。表示小于等于该数据的个数

![计数排序实例2](..\..\images\数据结构及算法\排序算法\计数排序实例2.jpg)

> C[1]=C[0]+C[1]=2+0=2；C[2]=C[1]+C[2]=2+2=4；表示小于等于2的数据有4个

* 此时C数组对应的值减去一就是对应A数组的索引位置。所以我们从后往前遍历A数组，然后把对应的元素放入到目标数组R对应的索引中，每次放入之后，需要对数组C对应的值减去一

> 比如A数组中出现3，那么3在C中对应的值是7，那么3应该放入R数组中7-1=6的index上，并且需要把C[3]--变成6。重复操作直到遍历完成。

![计数排序实例3](..\..\images\数据结构及算法\排序算法\计数排序实例3.jpg)

#### 2.3 复杂度

##### 2.3.1 时间复杂度

* O(n+k)
* 遍历A并计算C所花时间是O(n)，C累加所花时间是O(k)，再次遍历A并给R赋值所花时间是O(n)，因此，总时间为O(k + n)。所以k的值至关重要，如果过大就得不偿失了。在实际中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为O(n)。

##### 2.3.2 空间复杂度

* O(n+k)

#### 2.4  限制条件

* **数据范围不大**，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
* **计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数**

#### 2.5 适用场景

* 学生成绩排名

#### 2.6 实例代码

```java
class CountingSort {
    public static void main(String[] args) {
        CountingSort randomizedCollection = new CountingSort();
        randomizedCollection.countingSort(new int[]{2, 5, 3, 0, 2, 3, 0, 3}, 8);
    }


    //计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
    public void countingSort(int[] a, int n) {
        if (n <= 1) return;

        // 查找数组中数据的范围
        int max = a[0];
        for (int i = 1; i < n; ++i) {
            if (max < a[i]) {
                max = a[i];
            }
        }

        int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
        for (int i = 0; i <= max; i++) {
            c[i] = 0;
        }

        // 计算每个元素的个数，放入c中
        for (int i = 0; i < n; i++) {
            c[a[i]]++;
        }

        // 依次累加
        for (int i = 1; i <= max; ++i) {
            c[i] = c[i - 1] + c[i];
        }

        // 临时数组r，存储排序之后的结果
        int[] r = new int[n];
        // 计算排序的关键步骤，从后往前遍历
        for (int i = n - 1; i >= 0; i--) {
            int index = c[a[i]] - 1;
            r[index] = a[i];
            c[a[i]]--;
        }

        // 将结果拷贝给a数组
        for (int i = 0; i < n; ++i) {
            a[i] = r[i];
        }
    }

}
```

### 三、基数排序

#### 3.1 原理

* 对于一组数据，我们按照每一位对数据进行排序(最低位排序)。

#### 3.2 实例

> 源数据
>
> 433
>
> 233 
>
> 369
>
> 578

* 先按个位排序

>433
>
>233
>
>578
>
>369

* 再按十位排序

> 433
>
> 233
>
> 369
>
> 578

* 再按百位排序

> 233
>
> 369
>
> 433
>
> 578

#### 3.3 复杂度

##### 3.3.1 时间复杂度

* O(n)
* 对于每一位的排序，如果是计数排序的话就是O(n+k)，然后有d位进行排序，就是O(d*(n+k))，合理的话就是O(n)

#### 3.4 限制条件

* 数据需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
* 每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。
* 每一位的排序算法必须使用稳定排序算法

#### 3.5 稳定排序和不稳定排序

##### 3.5.1 稳定排序

含义：排序前的序列Ri==Rj且中Ri领先于Rj（即i<j）。若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。通俗的说就是保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。

* 插入排序
* 冒泡排序
* 合并排序
* 计数排序
* 基数排序算法

##### 3.5.2 不稳定排序

* 快速排序
* 堆排序

#### 3.6 实例代码

* 对于每个位采用的计数排序，整体使用的计数排序

```java
public class RadixSort {

    /**
     * 基数排序
     */
    public static void radixSort(int[] arr) {
        //找到最大值
        int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }

        // 从个位开始，对数组arr按"指数"进行排序
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSort(arr, exp);
        }
    }

    /**
     * 计数排序-对数组按照"某个位数"进行排序
     * @param exp 指数
     */
    public static void countingSort(int[] arr, int exp) {
        if (arr.length <= 1) {
            return;
        }
        
        //计算每个元素的个数
        int[] c = new int[10];
        for (int i = 0; i < arr.length; i++) {
            c[(arr[i] / exp) % 10]++;
        }

        //累加计算排序后的位置
        for (int i = 1; i < c.length; i++) {
            c[i] += c[i - 1];
        }

        //临时数组r，存储排序之后的结果
        int[] r = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            r[c[(arr[i] / exp) % 10] - 1] = arr[i];
            c[(arr[i] / exp) % 10]--;
        }

        //r复制到arr数组中
        for (int i = 0; i < arr.length; i++) {
            arr[i] = r[i];
        }
    }
}
```

